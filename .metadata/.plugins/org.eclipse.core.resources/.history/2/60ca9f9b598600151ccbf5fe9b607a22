
def de_queue(a_text, a_list):
    # Returns (0) a_list[FRONT_INDEX] + a_text AND
    # (1) a_list with a_list[FRONT_INDEX] removed

def describe_test_to_user():
    print("\nBY ACCEPTING OR REJECTING THE FRAGMENTS PRESENTED, RECONSTRUCT THE FIRST PART\n"
          " OF LINCOLN’S GETTYSBURG ADDRESS. (REJECTED FRAGMENTS REAPPEAR LATER UNTIL ACCEPTED).\n")
          
def move_from_front_to_back(a_list):
    
front_value = a_list.pop(FRONT_INDEX)
return new_text, new_list
return a_list
new_text = a_text + str(front_element)

    
def offer_front_fragment():
    '''
    Postcondition 1: "Select " + <the front element of fragment_choice> +
    " next (press 'n' for no)?: " is on monitor
    Postcondition 2: returns character that user pressed
    '''
# for "Returns (0) … (the first return)"
# for "Returns (1) …(the second return)"
front_element = a_list[FRONT_INDEX]
return input()

new_list = a_list  # (rather than try to manipulate parameters)

new_list.remove(front_element)
if fragment_selected_q != 'n':  # not "no"
a_list.append(front_value)
dequeue_results = de_queue(resulting_text, fragments_remaining)
# Fulfillment of Postconditions 1-2:
fragments_remaining = dequeue_results[1]
else:
resulting_text = str(dequeue_results[0])
# Fulfillment of Part(2) of Postcondition 1:
global resulting_text, fragments_remaining
# Fulfillment of Postcondition 1:
# Fulfillment of Part(1) of Postcondition 1:
fragment_selected_q = offer_front_fragment()
move_from_front_to_back(fragments_remaining)